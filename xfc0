#!/usr/bin/env perl

=head1 NAME

xfc - cross format converter for any of XML, YAML, JSON and INI formats.

=head1 SYNOPSIS

    xfc -f FORMAT -t FORMAT [OPTIONS]
    xfc -r FORMAT -w FORMAT [OPTIONS]
    xfc --from=FORMAT --to=FORMAT [OPTIONS]

=head1 DESCRIPTION

xfc is a naive command line tool to convert data between XML, YAML, JSON and INI formats.

=head1 OPTIONS

=over 4

=item B<-h>, B<--help>

Outputs this help page.

=item B<-r FORMAT>, B<-f FORMAT>, B<--from=FORMAT>

The mandatory option assumes the input file has the specified format.

=item B<-w FORMAT>, B<-t FORMAT>, B<--to=FORMAT>

The mandatory option assumes the output file has the specified format.

=back

=head1 FORMATS

The following formats are supported:

=over 4

=item B<INI>

=item B<JSON>

=item B<XML>

=item B<YAML> (B<YML> is allowed as shortcut)

=back

=head1 SEE ALSO

=head1 COPYRIGHT

Copyright 2017, 2020, 2021 Ildar Shaimordanov E<lt>F<ildar.shaimordanov@gmail.com>E<gt>

    MIT

=cut

# =========================================================================

use strict;
use warnings;

use Pod::Usage;
use Getopt::Long;

# =========================================================================

my %opts;

my $io;

sub set_format {
	my ( $name, $k, $v ) = @_;

	die "Unknown $name: $v\n"
	unless $v =~ m/^( xml | ya?ml | json | ini )$/x;

	$v = uc $v;
	$v =~ s/YML/YAML/;

	$io->{$name} = "Local::$v";
}

pod2usage unless 
GetOptions(
	'h|help'	=> sub { pod2usage({ -verbose => 2, -noperldoc => 1 }); },

	'r|f|from=s'	=> sub { set_format('reader', @_); },
	'w|t|to=s'	=> sub { set_format('writer', @_); },
)
&& defined $io->{reader}
&& defined $io->{writer}
;

die "-f/-r/--from option required\n" unless $io->{reader};
die "-t/-w/--to option required\n" unless $io->{writer};

# =========================================================================

my $text;
my $data;

# =========================================================================

$text = do { undef $/; <> };
$data = $io->{reader}->load($text);
$text = $io->{writer}->dump($data);
print $text;

# =========================================================================

{

package Local::Module::Find;

use List::Util qw( first );

our $DEBUG;
our $FATAL;

BEGIN {
	$FATAL = 1;
}

sub findfirst {
	shift if $_[0] eq __PACKAGE__ || ref $_[0] eq __PACKAGE__;

	my $pkg = first {
		my $pkg = eval "require $_; '$_'";
		warn "$@" if $DEBUG && $@;
		$pkg;
	} @_;

	die "Unable to load any of the list: @_\n" if ! $pkg && $FATAL;

	warn "Found: $pkg\n" if $DEBUG;

	$pkg;
}

};

# =========================================================================

{

package Local::INI;

# Borrowed from Config::Tiny

sub load {
	my ( $self, $text, $opts ) = @_;

	return undef unless defined $text;

	my $data;

	my $ns = '_';
	my $counter = 0;

	foreach ( split /(?:\015{1,2}\012|\015|\012)/, $text ) {
		$counter++;

		# Skip comments and empty lines.
 		next if /^\s*(?:\#|\;|$)/;
 
		# Remove inline comments.
 		s/\s\;\s.+$//g;
 
		# Handle section headers.
		if ( /^\s*\[\s*(.+?)\s*\]\s*$/ ) {
	 		# Create the sub-hash if it doesn't exist.
	 		# Without this sections without keys will not
	 		# appear at all in the completed struct.
	 		$data->{$ns = $1} ||= {};
	 		next;
		}
 
		# Handle properties.
		if ( /^\s*([^=]+?)\s*=\s*(.*?)\s*$/ ) {
	 		$data->{$ns}->{$1} = $2;
 	 		next;
		}

		die "Syntax error at line $counter: '$_'\n";
	}

	return $data;
}

sub dump {
	my ( $self, $data, $opts ) = @_;

	my $text = '';

	my $ns = $opts{default} || '_';

	for my $section ( sort {
		(($b eq $ns) <=> ($a eq $ns)) || ($a cmp $b) 
	} keys %$data ) {
		# Check for several known-bad situations with the section
		# 1. Leading whitespace
		# 2. Trailing whitespace
		# 3. Newlines in section name.
		die "Illegal whitespace in section name '$section'\n"
		if $section =~ /(?:^\s|\n|\s$)/s;

		my $block = $data->{$section};
		$text .= "\n" if length $text;
		$text .= "[$section]\n" unless $section eq $ns;

		for my $property ( sort keys %$block ) {
	 		die "Illegal newlines in property '$section.$property'\n"
	 		if $block->{$property} =~ /(?:\012|\015)/s;

	 		$text .= "$property=$block->{$property}\n";
		}
	}

	return $text;
}

};

# =========================================================================

{

package Local::JSON;

my $pkg;

sub load_pkg {
	$pkg = Local::Module::Find::findfirst(
		qw ( JSON JSON::Tiny JSON::XS JSON::PP )
	);

	# encode_json, decode_json
	$pkg->import;
}

sub load {
	my ( $self, $text, $opts ) = @_;
	load_pkg unless $pkg;
	decode_json($text);
}

sub dump {
	my ( $self, $data, $opts ) = @_;
	load_pkg unless $pkg;
	encode_json($data);
}

};

# =========================================================================

{

package Local::XML;

my $pkg;

sub load_pkg {
#	local $Local::Module::Find::FATAL = 0;

	$pkg = Local::Module::Find::findfirst(
		qw ( XML::Simple XML::Dumper )
	);

	# XMLin, XMLout
	# xml2pl, pl2xml
	$pkg->import;

	if ( $pkg eq 'XML::Simple' ) {
		no warnings 'once';
		$XML::Simple::PREFERRED_PARSER = 'XML::SAX::PurePerl';
		#$XML::Simple::PREFERRED_PARSER = 'XML::Parser';
	}
}

sub load {
	my ( $self, $text, $opts ) = @_;
	load_pkg unless $pkg;
	if ( $pkg eq 'XML::Simple' ) {
		XMLin($text);
	} elsif ( $pkg eq 'XML::Dumper' ) {
		xml2pl($text);
	}
}

sub dump {
	my ( $self, $data, $opts ) = @_;
	load_pkg unless $pkg;
	if ( $pkg eq 'XML::Simple' ) {
		XMLout($data);
	} elsif ( $pkg eq 'XML::Dumper' ) {
		pl2xml($data);
	}
}

};

# =========================================================================

{

package Local::YAML;

my $pkg;

sub load_pkg {
	$pkg = Local::Module::Find::findfirst(
		qw( YAML YAML::XS YAML::PP YAML::Tiny CPAN::Meta::YAML )
	);

	# Load, Dump
	$pkg->import;
}

sub load {
	my ( $self, $text, $opts ) = @_;
	load_pkg unless $pkg;
	Load($text);
}

sub dump {
	my ( $self, $data, $opts ) = @_;
	load_pkg unless $pkg;
	Dump($data);
}

};

# =========================================================================

# EOF
